package org.sonar.samples.java.utils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.SyntaxTrivia;
import org.sonar.samples.java.utils.MethodCommentUtils_bk.Type;

public class MethodCommentUtils {
	private static JavaFileScannerContext context;
	private static List<String> methodComments;
	private static EnumMap<Type, ArrayList<String>> commentLineTypes;
	public static HashMap<String, Integer> errMsgs;
	public static String declareMethod;
	public static MethodTree tree;
	public static String methodName;
	public static String prefix;

	public enum Type {
		DESCRIPTION, EMPTY_LINE, PARAM, RETURN, EXCEPTION, OTHER, EMPTY_LINE_WITHOUT_ASTERISK, INVALID_LINE_FORMAT,
		INVALID_PARAM_FORMAT, INVALID_DESCRIPTION_FORMAT, INVALID_RETURN_FORMAT, INVALID_EXCEPTION_FORMAT,
		INVALID_EXTRA_WHITESPACE_FORMAT;

		String errMsg = "";
		public Pattern regex;

		static {
			EMPTY_LINE.errMsg = CommonMessage.REMOVE_EMPTY_LINE;
			EMPTY_LINE_WITHOUT_ASTERISK.errMsg = CommonMessage.REMOVE_EMPTY_LINE_WITHOUT_ASTERISK;
			INVALID_LINE_FORMAT.errMsg = CommonMessage.INVALID_LINE_FORMAT;
			INVALID_DESCRIPTION_FORMAT.errMsg = CommonMessage.INVALID_DESCRIPTION_FORMAT;
			INVALID_PARAM_FORMAT.errMsg = CommonMessage.METHOD_INVALID_PARAM_FORMAT;
			INVALID_RETURN_FORMAT.errMsg = CommonMessage.METHOD_INVALID_RETURN_FORMAT;
			INVALID_EXCEPTION_FORMAT.errMsg = CommonMessage.METHOD_INVALID_EXCEPTION_FORMAT;

			DESCRIPTION.regex = Pattern.compile("^\\*\\s+[^@\\s]+.*$");
			INVALID_LINE_FORMAT.regex = Pattern.compile("^(?!\\* \\S+).*$");
		}

//		public static Type getType(String line) {// line==null is necessary?
//			if (line.isEmpty()) {// line==null is necessary?
//				return EMPTY_LINE_WITHOUT_ASTERISK;
//			} else if (line.equals("*")) {// *
//				return EMPTY_LINE;
//			}
////			int beginIndex=-1,endIndex=-1;
////			Type type=null;
//			String annotation = getAnnotation(line);
//			if (!Pattern.compile("^\\* \\S+").matcher(line).find()) {// invalid line fomrat
//				switch (annotation) {
//				case "@param":
//					commentTypes.get(Type.PARAM).add(line);
//					break;
//				case "@return":
//					commentTypes.get(Type.RETURN).add(line);
//					break;
//				case "@exception":
//				case "@throws":
//					commentTypes.get(Type.EXCEPTION).add(line);
//					break;
//				default:
//					
//					break
//				}
//				return INVALID_LINE_FORMAT;
//			} else {
//			}
//		}

		public static boolean match(Type type, String line) {
			return type.regex.matcher(line).find();
		}

		public static Type getType(String line) {// line==null is necessary?
			if (line.isEmpty()) {// line==null is necessary?
				return EMPTY_LINE_WITHOUT_ASTERISK;
			} else if (line.equals("*")) {// *
				return EMPTY_LINE;
			} else if (match(Type.DESCRIPTION, line)) {
				return line.endsWith("<br>") ? DESCRIPTION : INVALID_DESCRIPTION_FORMAT;
			}
//			String annotation = getAnnotation(line);
			if (match(Type.INVALID_LINE_FORMAT, line)) {// invalid line fomrat
//				switch (annotation) {
//				case "@param":
//					commentTypes.get(Type.PARAM).add(line);
//					break;
//				case "@return":
//					commentTypes.get(Type.RETURN).add(line);
//					break;
//				case "@exception":
//				case "@throws":
//					commentTypes.get(Type.EXCEPTION).add(line);
//					break;
//				default:
//					if (!annotation.startsWith("@")) {
//						commentTypes.get(Type.DESCRIPTION).add(line);
//					}
//					break;
//				}
				handleInvalidLineFormat(line);
				return INVALID_LINE_FORMAT;
			} else {
				return getLineFormat(line);
			}
		}

		public static void handleInvalidLineFormat(String line) {
			String annotation = getAnnotation(line);
			switch (annotation) {
			case "@param":
				commentLineTypes.get(Type.PARAM).add(line);
				break;
			case "@return":
				commentLineTypes.get(Type.RETURN).add(line);
				break;
			case "@exception":
			case "@throws":
				commentLineTypes.get(Type.EXCEPTION).add(line);
				break;
			default:
				if (!annotation.startsWith("@")) {
					commentLineTypes.get(Type.DESCRIPTION).add(line);
				}
				break;
			}
		}

		public static Type getLineFormat(String line) {
			String annotation = getAnnotation(line);
			switch (annotation) {
			case "@param":
				return validParamFormat(line) ? PARAM : INVALID_PARAM_FORMAT;
			case "@return":
				return validReturnFormat(line) ? RETURN : INVALID_RETURN_FORMAT;
			case "@exception":
			case "@throws":
				return validExceptFormat(line) ? EXCEPTION : INVALID_EXCEPTION_FORMAT;
			default:
				return OTHER;
			}
		}

		public static boolean validFormat(Type type, String line) {
			switch (type) {
			case PARAM:
				return validParamFormat(line);
			case RETURN:
				return validReturnFormat(line);
			case EXCEPTION:
				return validExceptFormat(line);
			default:
				return false;
			}
		}

		public static boolean validParamFormat(String line) {
			line = line.substring(8).replaceAll("\\s+", " ").trim();
			if (line.isEmpty()) {
				return false;
			}
			int lastIndex = -1;
			Matcher matcher = Pattern.compile("[<>,\\[\\]?]").matcher(line);
			while (matcher.find()) {
				lastIndex = matcher.end() - 1;
			}
			if (lastIndex == -1) {// primary type
				return line.chars().filter(c -> c == ' ').count() == 1;// int name
			} else {// String[] a
				return line.substring(lastIndex + 1).chars().filter(c -> c == ' ').count() == 1;
			}
		}

		public static boolean validReturnFormat(String line) {
			line = line.substring(9).replaceAll("\\s+", " ").trim();
			if (line.isEmpty()) {
				return false;
			}
			int lastIndex = -1;
			Matcher matcher = Pattern.compile("[<>,\\[\\]?]").matcher(line);
			while (matcher.find()) {
				lastIndex = matcher.end() - 1;
			}
			if (lastIndex == -1) {// primary type
				return line.chars().filter(c -> c == ' ').count() == 0;// int
			} else {
				return lastIndex == line.length() - 1;
			}
		}

		public static boolean validExceptFormat(String line) {
			return line.split("\\s+").length == 3;
		}

	}

	public static String getAnnotation(String line) {
		line = line.charAt(0) == '*' ? line.substring(1).trim() : line;
		int endIndex = line.indexOf(" ");
		return line.substring(0, endIndex != -1 ? endIndex : line.length());
	}

	private static void initMethodComments(JavaFileScannerContext javaFileScannerContext, MethodTree methodTree)
			throws Exception {
		context = javaFileScannerContext;
		tree = methodTree;

		errMsgs = new HashMap<>();
		declareMethod = getDeclare();

		methodName = tree.symbol().declaration().simpleName().name();
		prefix = String.format("[R4J][Method comment][%s]", methodName);

		methodComments = getMethodComments();
		commentLineTypes = getCommentLineTypes();

	}

	public static String getLine(int lineNo) {
		return context.getFileLines().get(lineNo - 1);
	}

	public static String getDeclare() {
		int lineNo = tree.modifiers().lastToken().line();
		StringBuilder sb = new StringBuilder(getLine(lineNo));
		while (sb.indexOf("{") == -1 && sb.indexOf(";") == -1) {
			sb.append(getLine(++lineNo));
		}
		return sb.toString().replaceAll("\\s+", "");
	}

	private static List<String> getMethodComments() throws Exception {
		List<SyntaxTrivia> methodComments = tree.firstToken().trivias();
		if (methodComments.isEmpty()) {
			throw new Exception(CommonMessage.METHOD_ABSENT_COMMENTS);
		} else if (methodComments.size() > 1) {
			throw new Exception(CommonMessage.METHOD_TOO_MANY_COMMENTS);
		} else {
			String methodComment = methodComments.get(0).comment();

			if (methodComment.startsWith("/**") && methodComment.endsWith("*/") && methodComment.length() > 4) {
				String[] lines = methodComment.substring(3, methodComment.length() - 2).trim().split("\\r?\\n");
				return Arrays.stream(lines).map(String::trim).collect(Collectors.toList());
			}
			throw new Exception(CommonMessage.METHOD_INVALID_COMMENT_FORMAT);
		}
	}

	public static EnumMap<Type, ArrayList<String>> getCommentLineTypes() {
		EnumMap<Type, ArrayList<String>> lineTypes = new EnumMap<>(Type.class);
		for (Type t : Type.values()) {
			lineTypes.put(t, new ArrayList<>());
		}
		int firstAnotationIndex = -1;
		for (int i = 0; i < methodComments.size(); i++) {
			String line = methodComments.get(i);
			Type type = Type.getType(line);
			lineTypes.get(type).add(line);
			if (type.equals(Type.EMPTY_LINE)) {
				if (!allowEmptyLine(lineTypes)) {
					errMsgs.put(type.errMsg, errMsgs.getOrDefault(type.errMsg, 0) + 1);
				}
			} else {
				if (!type.equals(Type.DESCRIPTION) && !type.equals(Type.INVALID_DESCRIPTION_FORMAT)
						&& firstAnotationIndex == -1) {
					firstAnotationIndex = i;
				}
				if (!type.errMsg.isEmpty()) {
					errMsgs.put(type.errMsg, errMsgs.getOrDefault(type.errMsg, 0) + 1);
				}
				if (!isOrderedLine(type)) {
					errMsgs.put(CommonMessage.METHOD_NOT_SORTED,
							errMsgs.getOrDefault(CommonMessage.METHOD_NOT_SORTED, 0) + 1);
				}
			}
		}

//		String desErrMsg = getFormatErrMsg(Type.DESCRIPTION);
//		String paramErrMsg = getFormatErrMsg(Type.PARAM);
//		String returnErrMsg = getFormatErrMsg(Type.RETURN);
//		String exceptErrMsg = getFormatErrMsg(Type.EXCEPTION);
//		if (!desErrMsg.isEmpty()) {
//			errMsgs.put(desErrMsg, 1);
//		}

		if (firstAnotationIndex != -1
				&& !Type.getType(methodComments.get(firstAnotationIndex - 1)).equals(Type.EMPTY_LINE)) {
			errMsgs.put(CommonMessage.METHOD_ABSENT_EMPTY_LINE, 1);
		}

//		if (!paramErrMsg.isEmpty()) {
//			errMsgs.put(paramErrMsg, 1);
//		}
//		if (!returnErrMsg.isEmpty()) {
//			errMsgs.put(returnErrMsg, 1);
//		}
//		if (!exceptErrMsg.isEmpty()) {
//			errMsgs.put(exceptErrMsg, 1);
//		}
//
//		return !errMsgs.isEmpty();
		return lineTypes;
	}

	private static boolean isOrderedLine(Type type, EnumMap<Type, ArrayList<String>> lineTypes) {
		switch (type) {
		case DESCRIPTION:
			return allowEmptyLine(lineTypes);
		case PARAM:
			return commentLineTypes.get(Type.RETURN).isEmpty() && commentLineTypes.get(Type.EXCEPTION).isEmpty();
		case RETURN:
			return commentLineTypes.get(Type.EXCEPTION).isEmpty();
		default:
			return true;
		}
	}

	private static boolean allowEmptyLine(EnumMap<Type, ArrayList<String>> lineTypes) {
		return lineTypes.get(Type.PARAM).isEmpty() && lineTypes.get(Type.RETURN).isEmpty()
				&& lineTypes.get(Type.EXCEPTION).isEmpty();
	}

	public static void check(JavaFileScannerContext javaFileScannerContext, MethodTree methodTree) {
		try {
			initMethodComments(javaFileScannerContext, methodTree);

			String desErrMsg = validSection(Type.DESCRIPTION);
			String paramErrMsg = validSection(Type.PARAM);
			String returnErrMsg = validSection(Type.RETURN);
			String exceptErrMsg = validSection(Type.EXCEPTION);

			if (!desErrMsg.isEmpty()) {
				errMsgs.put(desErrMsg, 1);
			}
			if (!paramErrMsg.isEmpty()) {
				errMsgs.put(paramErrMsg, 1);
			}
			if (!returnErrMsg.isEmpty()) {
				errMsgs.put(returnErrMsg, 1);
			}
			if (!exceptErrMsg.isEmpty()) {
				errMsgs.put(exceptErrMsg, 1);
			}

		} catch (Exception e) {
			errMsgs.put(e.getMessage(), 1);
			e.printStackTrace();
		}

	}

	public static String validSection(Type type) {
		int commentCount, declareCount;
		switch (type) {
		case DESCRIPTION:
			return commentLineTypes.get(Type.DESCRIPTION).isEmpty()
					&& commentLineTypes.get(Type.INVALID_DESCRIPTION_FORMAT).isEmpty()
							? CommonMessage.METHOD_ABSENT_DESCRIPTION
							: "";
		case PARAM:
			commentCount = commentLineTypes.get(Type.PARAM).size()
					+ commentLineTypes.get(Type.INVALID_PARAM_FORMAT).size();
			declareCount = tree.parameters().size();
			if (commentCount == declareCount) {
				return validParamSection() ? "" : CommonMessage.METHOD_INVALID_PARAM;
			} else if (commentCount > declareCount) {
				return CommonMessage.METHOD_TOO_MANY_PARAM;
			} else {
				return commentCount == 0 ? CommonMessage.METHOD_ABSENT_PARAM : CommonMessage.METHOD_LACK_OF_PARAM;
			}

		case RETURN:
			commentCount = commentLineTypes.get(Type.RETURN).size()
					+ commentLineTypes.get(Type.INVALID_RETURN_FORMAT).size();
			if (tree.returnType() == null || commentCount > 1) {
				return commentCount == 0 ? "" : CommonMessage.METHOD_TOO_MANY_RETURN;
			} else if (tree.returnType().symbolType().isVoid() && commentCount == 0) {
				return "";
			} else if (commentCount == 0) {
				return CommonMessage.METHOD_ABSENT_RETURN;
			} else {// 1==1
				return validReturnSection() ? "" : CommonMessage.METHOD_INVALID_RETURN;
			}

		case EXCEPTION:
			commentCount = commentLineTypes.get(Type.EXCEPTION).size()
					+ commentLineTypes.get(Type.INVALID_EXCEPTION_FORMAT).size();
			declareCount = tree.throwsClauses().size();
			if (commentCount == declareCount) {
				return validExceptSection() ? "" : CommonMessage.METHOD_INVALID_EXCEPTION;
			} else if (commentCount > declareCount) {
				return CommonMessage.METHOD_TOO_MANY_EXCEPTION;
			} else {
				return commentCount == 0 ? CommonMessage.METHOD_ABSENT_EXCEPTION
						: CommonMessage.METHOD_LACK_OF_EXCEPTION;
			}
		default:
			return "";
		}
	}

	public static boolean validParamSection() {
		String comments = String.join(",", commentLineTypes.get(Type.PARAM).stream()
				.map(p -> p.substring(8).replaceAll("\\* @param|\\s+|@[^)]*\\)", "")).collect(Collectors.toList()));
		String declare = declareMethod.split("[()]")[1];
		return declare.equals(comments);
	}

	public static boolean validReturnSection() {
		if (commentLineTypes.get(Type.RETURN).isEmpty()) {
			return true;
		}
		String comment = commentLineTypes.get(Type.RETURN).get(0).replaceAll("\\* @return|\\s+", "") + methodName;
		String declare = declareMethod.split("[()]")[0];
		return declare.endsWith(comment);
	}

	public static boolean validExceptSection() {
		String comments = String.join(",", commentLineTypes.get(Type.EXCEPTION).stream()
				.map(p -> p.replaceAll("\\* @exception|\\* @throws|\\s+", "")).collect(Collectors.toList()));
		String declare = declareMethod.split("[()]")[2];
		return !declare.startsWith("throws") || declare.startsWith(comments, 6);
	}

	public static List<String> getErrMsg() {
		List<String> msgs = new ArrayList<>();
		for (Entry<String, Integer> entry : errMsgs.entrySet()) {
			if (entry.getValue() == 1) {
				msgs.add(String.format("%s[%s]", prefix, entry.getKey()));
			} else {
				msgs.add(String.format("%s[%s][+%d locations]", prefix, entry.getKey(), entry.getValue()));
			}
		}
//			return msgs.size() > 5 ? Arrays.asList(String.format("[%s]", CommonMessage.METHOD_CHECK_RULE))
//					: msgs;
		return msgs;
	}
}